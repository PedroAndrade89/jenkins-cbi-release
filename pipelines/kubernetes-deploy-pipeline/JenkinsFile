pipeline {
  parameters {
    string(name: 'GREETING', defaultValue: 'Hello', description: 'How do you want to greet?')
    choice(name: 'BRANCH', choices: ['main', 'dev', 'feature'], description: 'Which branch to build?')
    booleanParam(name: 'TFLINT', defaultValue: true, description: "Setup Cloudwatch logging?")
    booleanParam(name: 'CHECKOV', defaultValue: true, description: "Setup Cloudwatch logging?")
    booleanParam(name: 'TFSEC', defaultValue: true, description: "Setup Cloudwatch logging?")
    choice(name: 'action', choices: 'create\ndestroy', description: 'Create/update or destroy the eks cluster.')
  }

  options {
    disableConcurrentBuilds()
    timeout(time: 40, unit: 'MINUTES') // Timeout
  }

  agent {
    label 'jenkins-slave'
  }

  environment {
    PATH = "/home/jenkins-slave/.local/bin/:${env.PATH}" // Add Ansible bin directory to PATH
    SECRET_NAME = "${env.cluster_name}-jenkins-sa-kubeconf" // Define the name of your secret in AWS Secrets Manager
  }

  stages {
    stage('Example') {
      steps {
        echo "${params.GREETING}, the chosen branch is ${params.BRANCH}"
      }
    }

    stage('Initialize Environment Variables') {
      steps {
        script {
          env.DIR = "" // Initialize DIR
          switch (env.BRANCH_NAME) {
            case 'qa':
              env.DIR = 'terraform/environments/qa'
              break
            case 'main':
              env.DIR = 'terraform/environments/prod'
              break
            case 'stage':
              env.DIR = 'terraform/environments/stage'
              break
            default:
              error "Unknown branch name: ${env.BRANCH_NAME}"
          }
        }
      }
    }

    stage('Run TFLint') {
      when {
        expression { env.TFLINT == 'true' }
      }
      steps {
        script {
          dir("${env.DIR}") {
            sh 'tflint --format=json > tflint-results.json'
            def tflintResults = readJSON file: 'tflint-results.json'
            if (tflintResults.errors.size() > 0) {
              error("TFLint reported errors.")
            }
          }
        }
      }
    }

    stage('Run Checkov') {
      when {
        expression { env.CHECKOV == 'true' }
      }
      steps {
        script {
          def checkovFailed = false
          dir("${env.DIR}") {
            try {
              sh 'checkov -d . --quiet --framework terraform --output json > checkov-results.json'
              def checkovResults = readJSON file: 'checkov-results.json'
              if (checkovResults.results.failed_checks) {
                checkovFailed = true
              }
            } catch (FileNotFoundException e) {
              checkovFailed = true
              error("Checkov results file not found: ${e.message}")
            } catch (Exception e) {
              checkovFailed = true
              echo "Error running Checkov: ${e.message}"
            }
          }
          if (checkovFailed) {
            archiveArtifacts artifacts: 'terraform/environments/stage/checkov-results.json', onlyIfSuccessful: false
            error("Checkov step failed.")
          }
        }
      }
    }

    stage('Run TFSec') {
      when {
        expression { env.TFSEC == 'true' }
      }
      steps {
        script {
          dir("${env.DIR}") {
            sh 'tfsec . --format=json --soft-fail > tfsec-results.json'
            def tfsecResults = readJSON file: 'tfsec-results.json'
            if (tfsecResults.results.any { result -> result.severity == "CRITICAL" }) {
              error("Critical alerts found by TFSec.")
            }
          }
        }
        archiveArtifacts artifacts: 'terraform/environments/stage/tfsec-results.json', onlyIfSuccessful: false
      }
    }

    stage('TF Validate') {
      when {
        expression { params.action == 'create' }
      }
      steps {
        script {
          dir(env.DIR) {
            withCredentials([
              [
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: 'jenkins-automate-user',
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
              ]
            ]) {
              sh """
                terraform init
                terraform validate
              """
            }
          }
        }
      }
    }

    stage('TF Apply') {
      steps {
        dir(env.DIR) {
          script {
            withCredentials([
              [
                $class: 'AmazonWebServicesCredentialsBinding',
                credentialsId: 'jenkins-automate-user',
                accessKeyVariable: 'AWS_ACCESS_KEY_ID',
                secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
              ]
            ]) {
              sh 'terraform plan -out=plan.out'
              input message: 'Do you want to apply the Terraform plan?', ok: 'Yes'
              sh 'terraform apply plan.out'
            }
          }
        }
      }
    }
  }

  post {
    always {
      cleanWs()
    }
  }
}
