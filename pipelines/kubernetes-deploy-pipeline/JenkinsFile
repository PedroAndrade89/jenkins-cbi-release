pipeline {
   parameters {
    choice(name: 'action', choices: 'create\ndestroy', description: 'Create/update or destroy the eks cluster.')
    choice(name: 'environment_type', choices: 'qa\nstage\nprod', description: 'Create/update or destroy the eks cluster.')
    string(name: 'cluster', defaultValue : 'demo', description: "EKS cluster name.")
    choice(name: 'k8s_version', choices: '1.30\n1.29\n1.28', description: 'K8s version to install.')
    string(name: 'num_workers', defaultValue : '3', description: "k8s number of worker instances.")
    string(name: 'max_workers', defaultValue : '10', description: "k8s maximum number of worker instances that can be scaled.")
    booleanParam(name: 'cw_logs', defaultValue : true, description: "Setup Cloudwatch logging?")
    booleanParam(name: 'cw_metrics', defaultValue : false, description: "Setup Cloudwatch metrics and Container Insights?")
    booleanParam(name: 'metrics_server', defaultValue : true, description: "Setup k8s metrics-server?")
    booleanParam(name: 'dashboard', defaultValue : false, description: "Setup k8s dashboard?")
    booleanParam(name: 'prometheus', defaultValue : true, description: "Setup k8s prometheus?")
    booleanParam(name: 'nginx_ingress', defaultValue : true, description: "Setup nginx ingress and load balancer?")
    booleanParam(name: 'ca', defaultValue : false, description: "Setup k8s Cluster Autoscaler?")
    booleanParam(name: 'cert_manager', defaultValue : false, description: "Setup cert-manager for certificate handling?")
    string(name: 'region', defaultValue : 'eu-west-1', description: "AWS region.")
  }

    options {
      disableConcurrentBuilds()
      timeout(time: 40, unit: 'MINUTES') // Timeout
      ansiColor('xterm')
    }

    agent {
        label 'jenkins-slave'
    }

    environment {
        PATH = "/home/jenkins-slave/.local/bin/:${env.PATH}" // Add Ansible bin directory to PATH
        SECRET_NAME = "${env.cluster_name}-jenkins-sa-kubeconf" // Define the name of your secret in AWS Secrets Manager
        switch (${env.BRANCH_NAME}) {
          case 'qa':
            DIR='terraform/environments/qa'
            break;
          case 'prod':
            DIR='terraform/environments/prod'
            break;
          case 'stage':
            DIR='terraform/environments/stage'
            break;
    }

    stages {
        stage('Output Branch Name') {
            steps {
                echo "Currently building branch: ${env.BRANCH_NAME}"
            }
        }
        // Other stages as needed
//         stage('Checkout') {
//             steps {
//                 script {
//
//                     // Checkout code
//                     git branch: "${env.branch_name}", credentialsId: 'github-pedro', url: params.git_url
//                 }
//             }
//         }
//
//         stage('Run TFLint') {
//             when {
//                 expression { env.TFLINT == 'true' }
//             }
//             steps {
//                 script {
//                     // Run TFLint
//                     dir("${env.DIR}") {
//                         sh 'tflint --format=json > tflint-results.json'
//                         def tflintResults = readJSON file: 'tflint-results.json'
//                         if (tflintResults.errors.size() > 0) {
//                             error("TFLint reported errors.")
//                         }
//                     }
//                 }
//             }
//         }
//
//         stage('Run Checkov') {
//             when {
//                 expression { env.CHECKOV == 'true' }
//             }
//             steps {
//                 script {
//                     // Initialize flag variable
//                     def checkovFailed = false
//
//                     // Run Checkov
//                     dir("${env.DIR}") {
//                         try {
//                             sh 'checkov -d . --quiet --framework terraform --output json > checkov-results.json'
//                             def checkovResults = readJSON file: 'checkov-results.json'
//                             if (checkovResults.results.failed_checks) {
//                                 checkovFailed = true
//                             }
//                         } catch (FileNotFoundException e) {
//                             checkovFailed = true
//                             error("Checkov results file not found: ${e.message}")
//                         } catch (Exception e) {
//                             checkovFailed = true
//                             echo "Error running Checkov: ${e.message}"
//                         }
//                     }
//                     // Archive Checkov results
//                     if (checkovFailed) {
//                         archiveArtifacts artifacts: 'terraform/environments/stage/checkov-results.json', onlyIfSuccessful: false
//                         error("Checkov step failed.")
//                     }
//                 }
//             }
//         }
//
//         stage('Run TFSec') {
//             when {
//                 expression { env.TFSEC == 'true' }
//             }
//             steps {
//                 script {
//                     // Run TFSec
//                     dir("${env.DIR}") {
//                         sh 'tfsec . --format=json --soft-fail > tfsec-results.json'
//                         def tfsecResults = readJSON file: 'tfsec-results.json'
//                         if (tfsecResults.results.any { result -> result.severity == "CRITICAL" }) {
//                             error("Critical alerts found by TFSec.")
//                         }
//                     }
//                 }
//                 // Archive TFSec results
//                 archiveArtifacts artifacts: 'terraform/environments/stage/tfsec-results.json', onlyIfSuccessful: false
//             }
//         }
//
//         stage('TF Validate and Plan') {
//           when {
//             expression { params.action == 'create' }
//           }
//           steps {
//             script {
//               dir("${env.DIR}") {
//               withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
//               credentialsId: params.credential,
//               accessKeyVariable: 'AWS_ACCESS_KEY_ID',
//               secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
//                 sh """
//                   terraform init
//                   terraform validate
//                   terraform plan \
//                     -var cluster-name=${params.cluster} \
//                     -var num-workers=${params.num_workers} \
//                     -var max-workers=${params.max_workers} \
//                     -var cw_logs=${params.cw_logs} \
//                     -var inst_key_pair=${params.key_pair} \
//                     -var ca=${params.ca} \
//                     -var k8s_version=${params.k8s_version} \
//                     -var aws_region=${params.region} \
//                     -out ${plan}
//                 """
//               }
//             }
//           }
//         }
//         }
//
//         stage('TF Apply') {
//             steps {
//                 dir('terraform/environments/stage') {
//                     script {
//                         withCredentials([[
//                             $class: 'AmazonWebServicesCredentialsBinding',
//                             credentialsId: 'jenkins-automate-user',
//                             accessKeyVariable: 'AWS_ACCESS_KEY_ID',
//                             secretKeyVariable: 'AWS_SECRET_ACCESS_KEY'
//                         ]]) {
//                             sh 'terraform init'
//                             sh 'terraform validate'
//                             sh 'terraform plan -out=plan.out'
//                             input message: 'Do you want to apply the Terraform plan?', ok: 'Yes'
//                             sh 'terraform apply plan.out'
//                         }
//                     }
//                 }
//             }
//         }
//
//         stage('TF Plan') {
//               when {
//                 expression { params.action == 'create' }
//               }
//               steps {
//                 script {
//                   withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
//                   credentialsId: params.credential,
//                   accessKeyVariable: 'AWS_ACCESS_KEY_ID',
//                   secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
//                     sh """
//                       terraform init
//                       terraform workspace new ${params.cluster} || true
//                       terraform workspace select ${params.cluster}
//                       terraform plan \
//                         -var cluster-name=${params.cluster} \
//                         -var vpc-network=${params.vpc_network} \
//                         -var vpc-subnets=${params.num_subnets} \
//                         -var inst-type=${params.instance_type} \
//                         -var num-workers=${params.num_workers} \
//                         -var max-workers=${params.max_workers} \
//                         -var cw_logs=${params.cw_logs} \
//                         -var inst_key_pair=${params.key_pair} \
//                         -var ca=${params.ca} \
//                         -var k8s_version=${params.k8s_version} \
//                         -var aws_region=${params.region} \
//                         -out ${plan}
//                     """
//                   }
//                 }
//               }
//         }
//
//        stage('Cluster setup') {
//              when {
//                expression { params.action == 'create' }
//              }
//              steps {
//                script {
//                  withCredentials([[$class: 'AmazonWebServicesCredentialsBinding',
//                  credentialsId: params.credential,
//                  accessKeyVariable: 'AWS_ACCESS_KEY_ID',
//                  secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
//
//                    sh "aws eks update-kubeconfig --name ${params.cluster} --region ${params.region}"
//
//                    // CW Metrics and Container Insights setup
//                    // https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Container-Insights-prerequisites.html
//                    // https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/Container-Insights-setup-EKS-quickstart.html
//                    if (params.cw_metrics == true) {
//                      echo "Setting up Cloudwatch metrics and Container Insights."
//                      sh """
//                        curl --silent https://raw.githubusercontent.com/aws-samples/amazon-cloudwatch-container-insights/latest/k8s-deployment-manifest-templates/deployment-mode/daemonset/container-insights-monitoring/quickstart/cwagent-fluentd-quickstart.yaml | \\
//                          sed "s/{{cluster_name}}/${params.cluster}/;s/{{region_name}}/${params.region}/" | \\
//                          kubectl apply -f -
//                      """
//                    }
//
//                    // https://docs.aws.amazon.com/eks/latest/userguide/metrics-server.html
//                    // Need metrics server for horizontal and vertical pod autoscalers, prometheus and k8s dashboard
//                    if (params.metrics_server == true) {
//                      echo "Setting up k8s metrics-server."
//                      sh "kubectl apply -f https://github.com/kubernetes-sigs/metrics-server/releases/latest/download/components.yaml"
//                    }
//
//                    // https://docs.aws.amazon.com/eks/latest/userguide/dashboard-tutorial.html
//                    if (params.dashboard == true) {
//                      echo "Setting up k8s dashboard."
//                      sh """
//                        kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.5/aio/deploy/recommended.yaml
//                        kubectl apply -f eks-admin-service-account.yaml
//                      """
//
//                      echo "You need to get the secret token and then use kubectl proxy to get to the dashboard:"
//                      echo "kubectl -n kube-system describe secret \$(kubectl -n kube-system get secret | grep eks-admin | awk '{print \$1}')"
//                      echo "kubectl proxy"
//                      echo "Then visit: http://localhost:8001/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/#!/login"
//                      echo "See docs at https://docs.aws.amazon.com/eks/latest/userguide/dashboard-tutorial.html"
//                    }
//
//                    // https://docs.aws.amazon.com/eks/latest/userguide/prometheus.html
//                    if (params.prometheus == true) {
//                      echo "Setting up k8s prometheus."
//                      sh """
//                        helm repo add prometheus-community https://prometheus-community.github.io/helm-charts
//                        helm repo update
//                        helm install prometheus prometheus-community/prometheus \
//                          --namespace prometheus \
//                          --create-namespace \
//                          --set alertmanager.persistentVolume.storageClass="gp2",server.persistentVolume.storageClass="gp2"
//                      """
//
//                      echo "To connect to prometheus, follow the instructions above, then connect to http://localhost:9090"
//                      echo "See docs at https://docs.aws.amazon.com/eks/latest/userguide/prometheus.html"
//                      echo "Alternativly use k8s Lens which is much easier (choose Helm for the Prometheus setup its not auto detected)."
//                    }
//
//                    if (params.ca == true) {
//                      echo "Setting up k8s Cluster Autoscaler."
//
//                      // Keep the google region logic simple; us or eu
//                      gregion='us'
//
//                      if (params.region =~ '^eu') {
//                        gregion='eu'
//                      }
//
//                      // CA image tag, which is k8s major version plus CA minor version.
//                      // See for latest versions: https://github.com/kubernetes/autoscaler/releases
//                      switch (params.k8s_version) {
//                        case '1.21':
//                          tag='0'
//                          break;
//                        case '1.20':
//                          tag='0'
//                          break;
//                        case '1.19':
//                          tag='1'
//                          break;
//                        case '1.18':
//                          tag='3'
//                          break;
//                        case '1.17':
//                          tag='4'
//                          break;
//                        case '1.16':
//                          tag='7'
//                          break;
//                      }
//
//                      // Setup documented here: https://docs.aws.amazon.com/eks/latest/userguide/cluster-autoscaler.html
//                      // Tested ca late 2021 on k8s 1.21.
//                      sh """
//                        kubectl apply -f https://raw.githubusercontent.com/kubernetes/autoscaler/master/cluster-autoscaler/cloudprovider/aws/examples/cluster-autoscaler-autodiscover.yaml
//                        kubectl -n kube-system annotate deployment.apps/cluster-autoscaler cluster-autoscaler.kubernetes.io/safe-to-evict="false"
//                        sleep 5
//                        kubectl -n kube-system get deployment.apps/cluster-autoscaler -o json | \\
//                          jq | \\
//                          sed 's/<YOUR CLUSTER NAME>/${params.cluster}/g' | \\
//                          jq '.spec.template.spec.containers[0].command += ["--balance-similar-node-groups","--skip-nodes-with-system-pods=false"]' | \\
//                          kubectl apply -f -
//                        kubectl -n kube-system set image deployment.apps/cluster-autoscaler cluster-autoscaler=${gregion}.gcr.io/k8s-artifacts-prod/autoscaling/cluster-autoscaler:v${params.k8s_version}.${tag}
//                      """
//                    }
//
//                    // See: https://aws.amazon.com/premiumsupport/knowledge-center/eks-access-kubernetes-services/
//                    // Also https://docs.nginx.com/nginx-ingress-controller/installation/installation-with-helm/
//                    // Switched to helm install late 2021 to simplify install across different k8s versions.
//                    if (params.nginx_ingress == true) {
//                      echo "Setting up nginx ingress and load balancer."
//                      sh """
//                        helm repo add nginx-stable https://helm.nginx.com/stable
//                        helm repo update
//                        helm install nginx-ingress nginx-stable/nginx-ingress --namespace nginx-ingress --create-namespace
//                        kubectl apply -f nginx-ingress-proxy.yaml
//                        echo "Dns name of nginx ingress load balancer is below:"
//                        kubectl get svc --namespace=nginx-ingress
//                      """
//                    }
//
//                    // Updated cert-manager version installed late 2021
//                    if (params.cert_manager == true) {
//                      echo "Setting up cert-manager."
//                      sh """
//                        helm repo add jetstack https://charts.jetstack.io || true
//                        helm repo update
//                        helm install cert-manager jetstack/cert-manager --namespace cert-manager --version v1.5.3 --set installCRDs=true --create-namespace
//                        sleep 30 # allow cert-manager setup in the cluster
//                        kubectl apply -f cluster-issuer-le-staging.yaml
//                        kubectl apply -f cluster-issuer-le-prod.yaml
//                      """
//                    }
//
//                  }
//                }
//              }
//            }
//
//        stage('Install nginx ingress controller') {
//                    script {
//                        // Use the credentials binding plugin to securely inject AWS credentials
//                        withCredentials([[$class: 'AmazonWebServicesCredentialsBinding', credentialsId: 'jenkins-ecr-access', accessKeyVariable: 'AWS_ACCESS_KEY_ID', secretKeyVariable: 'AWS_SECRET_ACCESS_KEY']]) {
//
//                        sh "aws eks update-kubeconfig --name ${params.cluster} --region ${params.region}"
       }
       post {
           always {
               // Cleanup
              cleanWs()
           }
       }
}